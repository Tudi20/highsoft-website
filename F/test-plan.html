<!DOCTYPE html>
<!-- Kitakarítottam az OpenOffice hülyeségeit, nyugodtan meg lehet köszönni. - Kláben -->
<html lang="hu">
<head>
	<meta charset="utf-8">
	<link rel="shortcut icon" type="image/jpeg" href="../img/highsoftlogov2.2.png">
	<link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<title>HighSoft F5</title>
	<style>
		@page {
    		margin: 16px;
		}

		.left {
    		text-align: left;
		}

		.right {
    		text-align: right;
		}

		.f35 {
			font-size: 35px;
		}

		.f29 {
			font-size: 29px;
		}

		.f21 {
			font-size: 21px;
		}

		.f19 {
			font-size: 19px;
		}

		.f17 {
			font-size: 17px;
		}

		.f16 {
			font-size: 16px;
		}
		
	</style>
</head>
<body class="grey darken-4 grey-text text-lighten-1">
	<div class="fixed-action-btn">
		<a class="btn-floating btn-large red" href="#">
		  <i class="large material-icons">arrow_upward</i>
		</a>
	</div>
<div class= "container" style="padding-top: 1vw; font-family: 'Montserrat', sans-serif">
<p style="margin-top: 42px;" class="f21 amber-text">Csoport neve:<font color="#bdbdbd"> HighSoft</font></p>

<p class="f21 amber-text">Feladatsorszáma:<font color="#bdbdbd"> 5</font></p>

<p class="f21 amber-text">Feladat címe:<font color="#bdbdbd"> RPG mobiljáték</font></p>

<p style="margin-top: 80px; font-weight: bold;" class="center f29">Tesztelési terv</p>

<p style="margin-top: 80px;" class="center f21 amber-text">Gyakorlatvezető:</p>

<p class="center f29" style="margin:30px" >SZŰCS MIKLÓS</p>

<p style="margin:10px " class="left f21 amber-text">Csoporttagok:</p>

<table class="centered" style="padding: 2em" >
	
	<tbody>
    <tr>
		<td>TAMÁS JANKA</td>
		<td>GIE0EJ</td>
		<td>TAMAS.JANKA95@GMAIL.COM</td>
	</tr>
	<tr>
		<td>SZILÁGYI GÁBOR</td>
		<td>S9NJK6</td>
		<td>GABSZI12345@GMAIL.COM</td>
	</tr>
	<tr>
		<td>JÓNIS BÁLINT</td>
		<td>LN40BG</td>
		<td>JONISBALINT@GMAIL.COM</td>
	</tr>
	<tr>
		<td>DUDÁS DÁNIEL</td>
		<td>VUXFKS</td>
		<td>D.DANIEL910617@GMAIL.COM</td>
	</tr>
	<tr>
		<td>KLÁBEN SZABOLCS BENCE</td>
		<td>H46LPD</td>
		<td>KLABEN.SZABOLCS@GMAIL.COM</td>
	</tr>
	
	
  </tbody>
</table>

<p style="margin: 48px" class=" right f21 amber-text">Beadás Dátuma:<br> <font color="#bdbdbd">2020. 11. 27.</font></p>

<table class="centered f16" style="padding: 2em" >
	<thead>
		<tr class="amber-text">
			<th>Dátum</th>
			<th>Verzió</th>
			<th>Leírás</th>
			<th>Szerző(k)</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>2020. 11. 27.</td>
			<td>1.0</td>
			<td>Első verzió</td>
			<td>Tamás Janka & Dudás Dániel</td>
		</tr>
		
	</tbody>
</table>


<p class="f21 amber-text" style="margin-top:40px">A megbeszélések időpontjai:</p>	
<table class="f19 centered "> 
	<tr >
		<td>
			<p class="amber-text">2020. 11. 20. 10:30</p>
			<p >Jelen lévő személyek:</p>
		</td>
		<td >
			<ul >
				<li>Dudás Dániel</li>
				<li>Kláben Szabolcs Bence</li>
				<li>Szilágyi Gábor</li>
                <li>Tamás Janka</li>
			</ul>
		</td>	
	</tr>
</table>

<h5 class="amber-text" style="margin-top:32px">Tartalomjegyzék</h5>
<ol class="f16 cyan-text text-darken-3">
	<li><a class="f16 cyan-text text-darken-3" href="#1">Bevezetés</a></li>
	<li><a class="f16 cyan-text text-darken-3" href="#2">A tesztelés szintjei</a></li>
	<li><a class="f16 cyan-text text-darken-3" href="#3">A tesztelés menete</a></li>
	<li><a class="f16 cyan-text text-darken-3" href="#4">Tesztelési technikák</a>
		<ol>
			<li><a class="f16 cyan-text text-darken-3" href="#41">Statikus tesztelés</a></li>
			<li><a class="f16 cyan-text text-darken-3" href="#42">Dinamikus tesztelés</a>
				<ol>
					<li><a class="f16 cyan-text text-darken-3" href="#421">Feketedobozos (specifikáció alapú) tesztelés</a></li>
					<li><a class="f16 cyan-text text-darken-3" href="#422">Fehérdobozos (strukturális) tesztelés</a></li>
				</ol>
			</li>
		</ol>
	</li>
	<li><a class="f16 cyan-text text-darken-3" href="#5">A tesztelés költségei, időpontja</a></li>
	<li><a class="f16 cyan-text text-darken-3" href="#6">Mellékletek</a></li>
</ol>

<h4 class="amber-text" id=1>1. Bevezetés</h4>
<p>Ezen dokumentum célja, hogy az alkalmazásunkban meglévő hibákat még az üzembe helyezés előtt megtaláljuk, ezzel növelve a szoftver minőségét és megbízhatóságát. Természetesen arra törekszünk, hogy a tesztelésünk a létező összes hibát felfedje, viszont mivel ez köztudottan nem lehetséges, így elsődlegesen a program azon funkcióit igyekszünk tesztelni, melyeket a felhasználók a legtöbbször fognak használni. Emellett előtérbe helyezzük azokat modulokat és bemeneteket, ahol a hibák a legvalószínűbbek.</p>

<h4 class="amber-text" id=2>2. A tesztelés szintjei</h4>
<ol>
	<li>Komponensteszt: a komponens teszt során a rendszer önálló részeit teszteljük fehérdobozos teszteléssel (lásd Tesztelési technikák). Ezen belül egységtesztet hajtunk végre, amelyben a metódusokat ellenőrizzük: megvizsgáljuk, hogy a metódus tényleges visszatérési értéke megegyezik-e az elvárttal. Mivel a programozási környezetünk (Eclipse IDE) támogatja ezen tesztek megírását, ezért ennek segítségével hajtjuk végre a tesztelést.</li>
	<li>Integrációs teszt: az integrációs teszt során a komponensek közti interfészeket, az operációs rendszer és a rendszer közti interfészt, illetve más rendszerek felé nyújtott interfészeket teszteljük. Igyekszünk a fejlesztés során minél hamarabb tesztelni, hogy megfelelő legyen a komponensek összeillesztése még mielőtt az integráció mértéke túl nagy lenne.</li>
	<li>Rendszerteszt: ennek során a kész szoftverterméket teszteljük feketedobozos módszerrel (lásd Tesztelési technikák). Megvizsgáljuk, hogy a program megfelel-e a követelmény- és funkcionális specifikációnak, illetve a rendszertervnek. Bár a rendszertesztet általában független tesztelők végzik, a szoftverünk esetében a fejlesztőcsapat fogja végezni az 1-2. szint mellett ezt a szintet is.</li>
	<li>Átvételi teszt:
		<ol>
			<li>Alfa teszt: ennek során egy segédprogram több millió véletlen egérkattintással ellenőrzi, hogy össze-vissza kattintgatva sem lehet kifektetni a programot. Emellett tervezünk valamilyen debuggert is használni a teszteléshez.</li>
			<li>Béta teszt. A béta tesztet a végfelhasználók egy szűk csoportja végzi. Ezt a csoportot a fejlesztőcsapat ismeretségi körében lévő, a fejlesztéstől független személyek alkotják majd.</li>
			<li>Felhasználói átvételi teszt: Ekkor a szűk felhasználói csoport helyett az összes felhasználó megkapja a szoftvert. A programunk esetében elérhetővé válik az alkalmazás store-on. Ekkor még nagy valószínűséggel léphet fel a programban nem várt hiba, melyet minél hamarabb orvosolni kell a felhasználók érdekében.</li>
		</ol>
	</li>
</ol>
<h4 class="amber-text" id=3>3. A tesztelés menete</h4>
<ol>
	<li>Tesztterv elkészítése: először leírjuk a teszt tárgyát, kigyűjtjük a tesztbázisból a teszt által lefedett követelményeket, majd meghatározzuk a kilépési feltételt.</li>
	<li>Tesztesetek tervezése: a tesztesetek leírják a szükséges tesztadatokat és az elvárt visszatérési értéket vagy viselkedést. A tesztadatok meghatározásához ún. ekvivalenciaosztályokat állítunk fel, majd határeset-elemzéssel kiegészítjük azokat (lásd Tesztelési technikák).</li>
	<li>Felkészülés a végrehajtásra: a tesztelési környezet kialakítása.</li>
	<li>Tesztek végrehajtása: teszt naplót vezetünk, melyben dokumentáljuk a végrehajtott lépéseket és az eredményeket.</li>
	<li>Kilépési feltételek vizsgálata: a tesztesetben leírt elvárt eredményt összehasonlítjuk a teszt naplóban lévő valós eredménnyel a kilépési feltétel alapján.</li>
	<li>Eredmények értékelése: az eredmények alapján kiértékeljük, hogy van e szükség további tesztek készítésére vagy sem.</li>
	<li>Jelentéskészítés.</li>
</ol>
<h4 class="amber-text" id=4>4. Tesztelési technikák</h4>
<p>A programtesztelés módszereit két csoportba oszthatjuk aszerint, hogy a tesztelés során végrehajtjuk-e a programot vagy nem. Ha csak a program kódját vizsgáljuk, akkor statikus, ha a programot végre is hajtjuk a tesztelés során, akkor dinamikus tesztelésről beszélünk.</p>
<p>A tesztelési technikákat csoportosítjuk aszerint is, hogy a teszteseteket milyen információ alapján állítjuk elő. Ezek alapján létezik fekete- és fehérdobozos teszt. A feketedobozos technika esetében a specifikáció alapján, míg a fehérdobozos módszer esetében a forráskód alapján készülnek a tesztesetek.</p>

<h5 class="amber-text" id=41>4.1 Statikus tesztelés</h5>
<p>A statikus teszteléshez a kód manuális felülvizsgálata mellett hozzátartozik a dokumentáció átnézése is. Szoftverünk jelenlegi állapotából adódóan elsődlegesen a dokumentáció felülvizsgálására fektettünk nagy hangsúlyt, ugyanis erre már a szoftvertervezés annak a fázisában is sort tudtunk keríteni, amikor még nem állt rendelkezésünkre futtatható verzió. Ekkor főleg a rendszertervezéssel kapcsolatos hibákat, valamint a követelményekkel kapcsolatos hiányosságokat próbáltuk felfedni (pl. minden funkció létezik-e).</p>
<p>A Skeleton váz elkészülte után már a forráskódot is át tudtuk nézni, amely során főleg olyan hibalehetőségekre koncentráltunk, mint: konvenciós hiba, szintaktikai vagy szemantikai hiba stb. Mivel ekkor már a kódot vizsgáltuk, ezért ez a vizsgálat fehérdobozos technikának minősül. </p>
<p>Miután elkészül a végtermék az összes algoritmussal, csak ekkor tudunk teljeskörű statikus tesztet végrehajtani, mely során olyan szempontokat ellenőrzünk a fentebb felsoroltak mellett, mint: </p>
<ul>
	<li>Algoritmus logikája: rosszul kidolgozott vagy kidolgozatlan részek, ellentmondások stb.</li>
	<li>Felhasználatlan objektumok: az egyes programegységek deklarációs részében szereplő konstansok, típusok, változók, eljárások, függvények, operátorok szerepelnek-e más programegység törzsében</li>
	<li>Felhasználatlan változóérték: amikor egy változónak értéket adunk, de nem használjuk semmire</li>
	<li>Érték nélküli változó: amikor egy kezdőérték nélküli változó hamarabb szerepel a kódban, mint az értékadása</li>
	<li>Felesleges értékadás</li>
	<li>Azonosan igaz/hamis logikai formulák: amikor egy elágazás vagy ciklusfeltétel formailag helyes, de az egyik ág biztosan nem hajtható végre. Ennek következménye, hogy a ciklus vagy végtelen lesz, vagy nem hajtódik végre a ciklusmag.</li>
	<li>Végtelen ciklus: pl. ha egy számlálós ciklusban megváltoztatjuk a ciklusváltozót vagy egy feltételes ciklusnál a ciklusfeltételben szereplő változók a ciklusmagban nem változhatnak meg stb.</li>
	<li>Érték nélküli függvény, operátor: amikor a függvény- vagy operátordefiníció elágazást tartalmaz, és az elágazás valamelyik ágán nem adunk vissza függvényértéket</li>
	<li>Mellékhatással járó függvény, operátor: a programozási nyelvek többsége megengedi, hogy a függvények megváltoztassák paramétereik értékét, vagy akár globális változókat is.</li>
</ul>
<p>Természetesen a fejlesztés közben is folyamatosan figyelünk ezekre a hibákra és igyekszünk még a termék befejezése előtt minél többet kiaknázni ezek közül.</p>

<h5 class="amber-text" id=42>4.2 Dinamikus tesztelés</h5>
<p>A statikus teszteléssel ellentétben a dinamikus tesztelési módszerek alapelve az, hogy a programot működés közben vizsgáljuk. </p>
<p>Ennek következtében a Skeleton vázunkat csak minimális szinten tudtuk tesztelni, hiszen az objektumoknak csak az interfésze definiált, illetve csak kiíratások és szükség esetén egyszerű elágazások szerepelnek a forráskódban. Ebben a fázisban ezért csak annyi volt az alapkövetelményünk, hogy a program hibamentesen fusson: a képernyőre mindent kiírjon rendeltetésszerűen, a megfelelő metódusokat meghívja, illetve a feltételekhez szükséges adatokat bekérje, majd végrehajtsa az utasításokat a leírtak szerint. </p>
<p>Ehhez fehérdobozos tesztelési technikát alkalmaztunk, amely során a forráskódot vizsgálva azt teszteltük, hogy a program minden osztályt és metódust létrehozott és kiírt-e a megfelelő sorrendben. </p>
<p>Az egyes interaktívabb programrészek (elágazások) esetében pedig feketedobozos módszert alkalmaztunk, amely során nem vettük figyelembe a program szövegét, csakis funkcionálisan, a programot használva teszteltük az adott részeket.</p>
<p>Miután elkészül a végtermék az összes algoritmussal, teljeskörű dinamikus tesztet ekkor tudunk végrehajtani, viszont a fejlesztéssel párhuzamosan is tesztelünk folyamatosan és igyekszünk még a termék elkészülte előtt minél több hibát felfedni. </p>
<p>A szoftverünket az alábbi tesztelési technikákkal tervezzük ellenőrizni:</p>

<h6 class="amber-text" id=421>4.2.1 Feketedobozos (specifikáció alapú) tesztelés</h6>
<ol>
	<li><p>Ekvivalenciaosztályok keresése</p>
	<p>A tesztelés alapelvei alapján jó tesztesetnek nevezzük az olyant, amelyre minél nagyobb valószínűséggel áll, hogy hibát találunk vele a programban. Ezt az elvet veszi figyelembe az ekvivalenciaosztályok módszere. Ekvivalenciaosztálynak nevezzük az input értékek olyan halmazát, amelyre ugyanúgy kell viselkednie a programnak. </p>
	<p>Ekvivalenciaosztályokat nemcsak az érvényes, hanem az érvénytelen adatokhoz is létrehozunk és a programot azokkal is kipróbáljuk. Miután meghatároztuk őket, a teszteseteket a következő két elv alapján hozzuk létre:</p>
	<ul>
		<li>amíg az érvényes ekvivalenciaosztályokat le nem fedtük, addig olyan teszteseteket készítünk, amelyek minél több érvényes ekvivalenciaosztályt lefednek;</li>
		<li>minden érvénytelen ekvivalenciaosztályra írunk egy-egy, az osztályt lefedő tesztesetet (több hiba esetén előfordulhat, hogy a hibás adatok lefedik egymást, az első hibajelzés miatt a másodikra már nem kerül sor).</li>
	</ul>
	<p>Az ekvivalencia osztályok meghatározása jelentősen csökkentheti a szükséges tesztesetek számát. Mindemellett az ekvivalenciaosztályok átfedhetik egymást, ennek következtében tovább csökkenhet a tesztesetek száma.</p>
	</li>

	<li><p>Határeset-elemzés</p>
	<p>Általánosságban kijelenthető, hogy a határértékek kezelésénél könnyebben követnek el hibát a programozók, ezért célszerű az ekvivalencia osztályok határértékeit külön megvizsgálni. </p>
	<p>Az ekvivalenciaosztályok keresésének módszerét a következőkkel egészítjük ki a határeset-elemzés során:</p>
	<ul>
		<li>az ekvivalenciaosztály kiválasztott elemének a határon levő elemeket választjuk;</li>
		<li>nemcsak a bemeneti, hanem a kimeneti ekvivalenciaosztályt is figyelembe vesszük.</li>
	</ul>
	</li>

	<li><p>Használati eset (use case) tesztelés</p>
	<p>A fejlesztési projektünk része egy Szoftver követelmény specifikáció dokumentum, melyben Use Case diagramokkal ábrázoltuk a rendszer funkcionális működését. Ezt felhasználva a teszteseteket a használati esetekkel írjuk le, melyet egy ún. teszt lefedettségi mátrixszal ábrázolunk. </p>
	<p>Ezzel az eszközzel egyrészt követni tudjuk, hogy hol tartunk a tesztelési folyamatban, másrészt segítségével ellenőrizhető, hogy minden használati esethez tartozik-e legalább egy teszteset.</p>
	</li>
</ol>

<h6 class="amber-text" id=422>4.2.2 Fehérdobozos (strukturális) tesztelés </h6>
<p>Az ilyen módszereknél a tesztelés három lépés egymásutánjából áll:</p>
<ul>
	<li>egy kipróbálási stratégiát választunk a program szerkezete alapján (utasítások egyszeri lefedésének elve, döntéslefedés elve stb.)</li>
	<li>a stratégia alapján megadott tesztutakhoz tesztpredikátumokat rendelünk;</li>
	<li>a tesztpredikátumok ekvivalenciaosztályokat jelölnek ki, amelyekből egy-egy tesztesetet választunk.</li>
</ul>
<p>Mivel a struktúra alapú tesztelés bonyolult és erőforrás igényes feladat (végrehajtásához speciálisan erre a célra fejlesztett eszközök kellenek), emellett a programunk váratlan viselkedése a rendszeréből adódóan nem okozna jelentős kárt, ezért a tesztelés során ilyen módszereket nem alkalmazunk.</p>

<h4 class="amber-text" id=5>5. A tesztelés költségei, időpontja</h4>
<p>Csak a végtermék elkészülte után végezhetjük el a teljes rendszertesztet, viszont a Skeleton váz és a programterv dokumentációk ellenőrzésére, illetve az egység- és integrációstesztre már a korábbi fázisokban is sort tudunk keríteni, melyeket folyamatosan, a tervezéssel és fejlesztéssel párhuzamosan hajtunk végre.</p>
<p>Mivel egyetlen módszerrel sem lehetséges a kimerítő tesztelés, így arra törekszünk, hogy az összes lehetséges teszteset halmazából a lehető leghatékonyabb teszteset-csoportot kiválasszuk. A tesztelés hatékonyságát a tesztelés költsége és a felfedett hibák aránya határozza meg. A leghatékonyabb teszteset-csoport tehát minimális költséggel maximális számú hibát fed fel.</p>
<p>Ennek tekintetében terveink szerint a fejlesztőcsapat minden tagja részt vesz a tesztelésben (5 fő) napi 4-8 órában. Ebben a felállásban a kész szoftver várható tesztelési időtartama kb. 2 hét lesz. Ez idő alatt minden olyan fontos tesztesetet ki tudunk próbálni, amely a termék átadásához szükséges az átvételi tesztre, ahol már felhasználók fognak tesztelni. A elkészült alkalmazás tesztelésének kezdő időpontja egyelőre tisztázatlan, a szoftver elkészültétől függ.</p>
<h4 class="amber-text" id=6>6. Mellékletek</h5>
<a href="dict.html" class="waves-effect waves-light btn amber darken-2">Szótár</a>
</div>
</body>
</html>